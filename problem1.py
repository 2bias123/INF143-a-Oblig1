import bit_operations as bit_op

# initialize the LFSR with a binary sequence of length 30
# where all bits are 0 except the first and last bits which are 1
initial = [1 if i==0 or i==29 else 0 for i in range(30)]

# Polynomial: x^30 + x^23 + x^2 + x^1 + 1
    
# define the polynomial used in the LFSR
# represented as a list of indices of the feedback lines in the LFSR
pol = [0,1,2,23]

# define a function to perform the LFSR algorithm
# takes three inputs: the polynomial, the initial state of the LFSR, and the number of iterations to perform
# returns a list of bits generated by the LFSR
def lfsr(polynomial: list, initialState: list, itr: int, returnval: list) -> list:
    # check if the initial state is of length 30 and if the number of iterations is greater than 0
    if len(initialState) == 30 and itr > 0:
        # select certain bits from the current state based on the polynomial
        selectedcells: list = []

        for i in polynomial:
            selectedcells.append(initialState[29-i])

        # XOR the selected bits together to generate a new state bit
        res: int = selectedcells[0]
        for i in range(1,len(selectedcells)):
            res = bit_op.xor(res, selectedcells[i])

        # append the current output bit to the return value list
        returnval.append(initialState.pop())

        # update the current state by shifting all bits to the right and inserting the new state bit at the leftmost position
        initialState.insert(0,res)

        # recursively call the lfsr function with the updated state and decreased iteration count
        return lfsr(pol,initialState,itr-1,returnval)

    # when the number of iterations is zero, return the list of output bits
    elif itr <= 0:
        return returnval

# perform the LFSR algorithm with the specified polynomial and initial state for 500 iterations
outs: list = lfsr(pol,initial,500,[])

# write the output bits to a file named "answerTask1.txt"
with open("answerTask1.txt","w") as out:
    for i in outs:
        out.write(str(i))

